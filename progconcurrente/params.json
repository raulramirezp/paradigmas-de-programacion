{
  "name": "Concurrent.GitHub.io",
  "tagline": "For Everyone",
  "body": "# Programación Concurrente\r\n\r\n#Filosofía\r\nEs la división de  un problema en subproblemas  que se solucionan de forma individual, para crear un programa o aplicación que no se vea afectada en tiempo real\r\n\r\n#Definición:\r\nHace referencia a las técnicas de programación que son utilizadas para expresar la concurrencia entre tareas y solución de los problemas de comunicación y sincronización entre procesos\r\n\r\n#Conceptos clave\r\nPara entender el funcionamiento, a nivel de sistema operativo,de la programación concurrente, es necesario tener claro que es un proceso, y como se representa en la máquina, para ello vamos a ver que es un proceso:\r\n\r\n#Proceso\r\nUn proceso no solamente es el código de un programa,un proceso tiene un **contador de programa** el cual es un registro del computador que indica la dirección de la siguiente instrucción que será ejecutada por el proceso, **Pila de proceso** Esta contiene datos temporales tales como: Los parametros de las funciones, direcciones de retorno, variables locales , … , **Sección de datos** la cual contiene datos tales como las variables locales, Heap: Cúmulo de memoria que es la memoria que se asigna dinámicamente al proceso n tiempo de ejecución\r\n\r\n![](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_01_Process_Memory.jpg)\r\n\r\n\r\n**Note** que un programa por sí sólo no es un proceso, ya que este es una entidad pasiva que contiene una lista de instrucciones almacenadas en disco ( archivo ejecutable),  mientras que un proceso es una entidad activa, el cual cumple todas las características descritas anteriormente.\r\n\r\n**Estados del proceso**\r\nCuando un proceso es ejecutado este cambia de estados, los estados que todo proceso tiene por lo general son:\r\n\r\n* **Nuevo**:        El proceso se está creando.\r\n\r\n* **Corriendo**:        Se están ejecutando las instrucciones.\r\n\r\n* **Espera**:        El proceso está esperando que algún evento ocurra.\r\n\r\n* **Preparado**:    El proceso está esperando ser asignado al procesador.\r\n\r\n* **Terminado**:    El proceso a terminado la ejecución.\r\n![](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_02_ProcessState.jpg)\r\n\r\n**PCB ( Bloque de control de proceso )**\r\nCada proceso se representa en el sistema operativo mediante el PCB, entre los elementos de información que este contiene se encuentran:\r\n\r\n* **Estado del proceso**:  New, ready, running, waiting, halted, ...\r\n\r\n* **Contador del programa**: \r\n\r\n* **Registros de la CPU**:    Estos varían en cuanto a número y tipo dependiendo  de la arquitectura del procesador\r\n\r\n* **Información de planificación de la CPU**: Parametros de planificación como prioridad de procesos, punteros  a las colas de planificación ...\r\n\r\n* **Información de gestión de memoria**: Tablas de paginas , tablas de segmentos, dependiendo los mecanismos de gestión del S.O\r\n\r\n![](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_03_PCB.jpg)\r\n\r\n#Hilo\r\n\r\nSe puede definir como una unidad básica de utilización del CPU. Cada hilo tiene:\r\nId de hilo,  Contador de programa,  Registros, Pila.\r\nLos hilos que pertenecen a un mismo proceso comparten:\r\nSección de código, sección de datos, entre otros recursos del sistema.\r\n\r\n#Multiprogramación\r\nEs una técnica de multiplexación que permite de múltiples procesos en un único procesador.\r\nEs importante resaltar que los procesos nunca corren en paralelo en el procesador, ya que en cada instante de tiempo solo se ejecuta un proceso en el procesador.\r\n\r\n#Multiproceso\r\nEs una técnica en la cual se hace uso de dos o más procesadores en una computadora para ejecutar uno o varios procesos.\r\n\r\n#Procesamiento distribuido\r\nEs cuando uno o varios procesos son ejecutados en una o más computadores\r\n\r\n# Programacion Paralela y Concurrente\r\n## Relacion\r\nMultiples procesos pueden ser ejecutados al mismo tiempo. En otra palabras, la programacion concurrente se comporta igual que la paralela cuando tenemos un sistema multiprocesador en el cual cada unidad de procesamiento ejecuta un proceso o hilo. En la imagen inferior podemos ver que el la unidad de procesamiento 2 y 3 se comportan igual.\r\n\r\n![](http://s32.postimg.org/s503ixn05/paralellismo.jpg)\r\n\r\nHay que aclarar la concurrencia no solo es paralelismo, ya que, cuando hay mas procesos o hilos el scheduler del sistema operativo interviene y divide la ejecucion de los procesos, **caracteristica que la programacion paralela NO tiene** cada proceso tiene que ser ejecutado exclusivamente en una unidad de procesamiento. En la parte inferior podemos apreciar mejor la diferencia.\r\n\r\n![](http://joearms.github.io/images/con_and_par.jpg)\r\n\r\n# Sincronizacion\r\n\r\nCuando tenemos varios procesos o hilos en la ejecucion, en muchos casos no queremos que estos se ejecuten al mismo tiempo. El mecanismo que controla el orden de ejecucion de determinadas tareas lo llamamos **SINCRONIZACION**.\r\n\r\n\r\n_**Porque el algunos casos no queremos que los hilos se ejecuten al mismo tiempo?**_\r\n\r\n![](http://www.blogdepsicologia.com/wp-content/uploads/2015/06/ansiedad-2.jpg)\r\n\r\n\r\n## Problema del Lector - Escritor\r\n\r\nCuando tenemos varios lectores y escritores, por ejemplo, en un base de datos, muchos procesos van a intentar leer o escribir al mismo tiempo, lo cual no podemos permitir, ya que, nuestra informacion se podria perder, duplicar, corromper entre otros. Solo es posible que un proceso leo o escriba y que los demas esperen su turno. \r\n\r\n## Problema de los filosofos que cenan\r\n\r\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/An_illustration_of_the_dining_philosophers_problem.png/200px-An_illustration_of_the_dining_philosophers_problem.png)\r\n\r\nCada filósofo pueda tomar los tenedores que están a su izquierda o derecha, para poder comer el filósofo de tener los dos tenedores. Si cualquier filósofo toma los dos tenedores entonces los que están al lado queda en espera. Hay un tenedor y los dos filósofos compiten por tomarlo y uno queda sin tenedores. \r\n\r\nSi todos los filósofos toman el tenedor que está a su derecha entonces todos se quedaran esperando infinitamente. Nadie va a ceder su tenedor porque todos están en la misma situación.\r\n\r\nComo podemos hacer para que los filósofos no se mueran de hambre?. Interesante no, el problema en sí tiene muchas soluciones pero solo vamos a enunciar una: Un filosofo toma los dos tenedores y se los demas hacen una cola alrededor de la mesa para saber cual es el siguiente hasta que todos acaban.\r\n\r\n# Metodos de Sincronización\r\n\r\nHay muchos metodos de sincronizacion vamos a mostrar los mas importantes.\r\n\r\n* Semaforos\r\n* Tuberias\r\n* Paso de mensaje\r\n\r\n## Semaforos\r\n\r\nSon variables que almacenan un valor entero y en la que hay tres operaciones básicas: inicialización, incremento y decremento. Las tres operaciones son atómicas, lo que significa que durante la ejecución nunca se va a interrumpir el proceso. Con estas operaciones constituyen unos métodos para permitir o restringir el acceso a la sección crítica.\r\n\r\n* Se inicializa con un valor entero mayor que cero generalmente uno\r\n* Se hace un decremento. Después se evalúa si el valor del semáforo es menor o igual a cero esta función se bloquea\r\n* Se hace un incremento. Si el valor del semáforo es mayor que cero, el proceso bloqueado será desbloqueado\r\n\r\n## Mutex\r\n\r\nEs la implementación a más alto nivel teniendo en cuenta el software y hardware se suele utilizar:\r\n\r\n* Semaforos\r\n* Monitores\r\n* Paso de mensajes\r\n* Pipes\r\n* Bloqueos recursivo\r\n* Bloqueos temporizados\r\n\r\nSe suelen utilizar los siguientes métodos generales:\r\n\r\n* Iniciar Mutex\r\n* Bloquear seccion critica\r\n* Desbloquear seccion critica\r\n* Destruir Mutex\r\n\r\n# Ventajas\r\n\r\n* Mejor rendimiento en un sistema monoprocesador\r\n* Fiable administración de los datos en sistemas con gran información\r\n* Permite el desarrollo de aplicaciones que no se vean afectadas en tiempo real\r\n* Mejor aprovechamiento de la CPU\r\n\r\n# Desventajas\r\n\r\n* Consumos de recursos cuando hay excesos de hilos o procesos\r\n* En programas con pocas instrucciones en mas lento\r\n* Desarrollo\r\n\r\n# Aplicaciones \r\n\r\n1. Servidores Web\r\n2. Sistema multimedia\r\n3. Calculo numerico\r\n4. Interaccion por GUI\r\n5. Sistemas gestores de bases de datos\r\n6. Sistemas Operativos\r\n\r\n# Lenguajes\r\n\r\n* Ejemplo en **python**: Este es un pequeño ejemplo con el fin de ilustrar como podemos lanzar un hilo en python\r\n\r\n```python\r\nfrom threading import Thread\r\nimport time\r\n\r\ndef say_hello(name):\r\n    print (name, \"Hola\")\r\n\r\nt = Thread(target=say_hello, args=(\"world\",))\r\nt.start()\r\nt.join()\r\n```\r\n\r\n**Ejecucion:** python archivo.py\r\n\r\n> ('world', 'Hola')\r\n\r\n\r\n* Ejemplo en *GO*: En este ejemplo podemos visualizar que los hilos no se ejecutan en el orden ascedente si no esto lo decide el scheduler del sistema operativo\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n    \"time\"\r\n)\r\n\r\nconst FINAL = 100 * time.Millisecond\r\n\r\nfunc saluda(i int) {\r\n    time.Sleep(10 * time.Duration(i%5) * time.Millisecond )\r\n    fmt.Println(\"Hola a todos\", i)\r\n}\r\n\r\nfunc main() {\r\n    for i := 1; i <= 6; i++ {\r\n        // Lanzamos nuestro hilo solo anteponiendo la palabra go a la funcion\r\n        go saluda(i)\r\n    }\r\n    time.Sleep(FINAL)\r\n}\r\n```\r\n\r\n**Ejecucion:** go run archivo.go\r\n\r\n\r\n>Hola a todos 5\r\n\r\n>Hola a todos 6\r\n\r\n>Hola a todos 1\r\n\r\n>Hola a todos 2\r\n\r\n>Hola a todos 3\r\n\r\n>Hola a todos 4\r\n\r\n\r\n* Ejemplos semaforo en **C**: El siguiente codigo fuente solo sirve sistemas operativos basado en unix.\r\n\r\n```c\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <pthread.h>\r\n#include <unistd.h>\r\n#include <sys/types.h>\r\n#include <fcntl.h>\r\n#include <sys/stat.h>      \r\n#include <semaphore.h>\r\n\r\n#define NUMHILOS 5\r\n\r\nsem_t *semaforo;\r\nint error, i, parametro, a;\r\nchar t;\r\nvoid *z;\r\n\r\nvoid *fun(void *ap )\r\n{\r\n    sem_t *sem = ap;\r\n    char t;\r\n    sem_wait( sem ); // Bloqueamos seccion critica\r\n    printf( \"\\n Hilo ENTRO a seccion critica\" );\r\n    fflush( stdout );\r\n    sleep( 1 );\r\n    printf( \"\\n Hilo SALIO a seccion critica\\n\\n\" );\r\n    fflush( stdout );\r\n    sem_post( sem ); // Desbloqueamos seccion critica\r\n}\r\n\r\nint main()\r\n{\r\n    // Creamos nuestro semaforo\r\n    semaforo = sem_open( \"sema\", O_CREAT, 0666, 1 );\r\n\r\n    // Declaramos el descritor de los hilos\r\n    pthread_t hilos[NUMHILOS];\r\n\r\n    // Creamos nuestros hilos\r\n    for( i = 0; i < NUMHILOS; i++ )\r\n        pthread_create( &hilos[i], NULL, (void *)fun, semaforo );\r\n\r\n    // Esperamos a que nuestro hilos de ejecutan antes de terminar el programa\r\n    for( i = 0; i < NUMHILOS; i++ )\r\n        pthread_join( hilos[i], (void *)&z );\r\n\r\n    // Destruimos nuestro semaforo\r\n    sem_unlink( \"sema\" );\r\n    sem_close( semaforo );\r\n    return 0;\r\n}\r\n```\r\n\r\nCompilamos: **gcc semaforo.c -o semaforo -pthread**\r\n\r\n\r\nEjecutamos: **./semaforo**\r\n\r\n> Hilo ENTRO a seccion critica\r\n\r\n> Hilo SALIO a seccion critica\r\n\r\n> Hilo ENTRO a seccion critica\r\n\r\n> Hilo SALIO a seccion critica\r\n\r\n> Hilo ENTRO a seccion critica\r\n\r\n> Hilo SALIO a seccion critica\r\n\r\n* Ejemplo en **C++**: Calculamos el numero pi con 4 hilos con la ayuda de [Serie de Leibniz](https://es.wikipedia.org/wiki/Serie_de_Leibniz) \r\n\r\n```c++\r\n#include <iostream>\r\n#include <thread>\r\n#include <vector>\r\n\r\nusing namespace std;\r\nvector<double> valorCal( 4, 0.0 ), limites;\r\n\r\nvoid calcularIntervalo (int index)\r\n{\r\n    for (int i = limites[index]; i < limites[index+1]; i++)\r\n        if (i % 2 == 0)\r\n            valorCal[index] += 1.0/(2*i+1);\r\n        else\r\n            valorCal[index] -= 1.0/(2*i+1);\r\n}\r\n\r\nint main()\r\n{\r\n    // Creamos nuestro limites\r\n    int numeroSerie = 1000000000;\r\n    limites.push_back( 0 );\r\n    limites.push_back( numeroSerie/4 );\r\n    limites.push_back( numeroSerie/2 );\r\n    limites.push_back( 3*(numeroSerie/4) );\r\n    limites.push_back( numeroSerie );\r\n\r\n    // Creamos a hilos\r\n    thread hilos[4];\r\n\r\n    // Inicializamos nuestros hilos\r\n    for (int i = 0; i < 4; i++)\r\n        hilos[i] = thread( calcularIntervalo, i );\r\n\r\n    // Esperemos a que nuestros hilos terminen\r\n    for (int i = 0; i < 4; i++)\r\n        hilos[i].join();\r\n\r\n    // Calculamos nuestra respuesta\r\n    double answer = 0;\r\n    for (int i = 0; i < 4; i++)\r\n        answer += valorCal[i];\r\n    answer *= 4;\r\n    printf( \"EL valor de pi es:\\t%.20f\\n\", answer );\r\n    return 0;\r\n}\r\n```\r\nCompilar: **g++ pi.cpp -o pi -std=c++11 -pthread**\r\n\r\nEjecutar: **./pi**\r\n\r\n> EL valor de pi es:\t3.14159265258921038821\r\n\r\n# Referencias\r\n\r\n* [https://go-tour-es.appspot.com/#1](https://go-tour-es.appspot.com/#1)\r\n* [https://geekytheory.com/concurrencia-en-javascript/](https://geekytheory.com/concurrencia-en-javascript/)\r\n* [http://www.ctr.unican.es/asignaturas/procodis_3_ii/doc/procodis_3_01.pdf](http://www.ctr.unican.es/asignaturas/procodis_3_ii/doc/procodis_3_01.pdf)\r\n* [http://www.genbetadev.com/python/multiprocesamiento-en-python-threads-a-fondo-introduccion](http://www.genbetadev.com/python/multiprocesamiento-en-python-threads-a-fondo-introduccion)\r\n* [http://www.ctr.unican.es/asignaturas/procodis_3_ii/doc/procodis_1_01.pdf](http://www.ctr.unican.es/asignaturas/procodis_3_ii/doc/procodis_1_01.pdf)\r\n* [http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-189-multicore-programming-primer-january-iap-2007/lecture-notes-and-video/l4-introduction-to-concurrent-programming/](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-189-multicore-programming-primer-january-iap-2007/lecture-notes-and-video/l4-introduction-to-concurrent-programming/)\r\n* [https://sites.google.com/a/unal.edu.co/sistemas-operativos/](https://sites.google.com/a/unal.edu.co/sistemas-operativos/)\r\n* [https://www.fing.edu.uy/tecnoinf/mvd/cursos/so/material/teo/so07-concurrencia.pdf](https://www.fing.edu.uy/tecnoinf/mvd/cursos/so/material/teo/so07-concurrencia.pdf)\r\n* Abraham Silberschatz-Operating System Concepts (9th,2012.12)\r\n\r\n# Intregrantes\r\n* Jhon Emmanuel Torres\r\n* Raul Ramirez Penagos\r\n* Diego Rodriguez",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}